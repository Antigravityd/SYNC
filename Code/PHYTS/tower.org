
* Introduction

PHITS (Particle and Heavy Ion Transport code System) is Fortran software used widely by medical physicists. However, the speed Fortran provides is at the expense of integration with many common utilities for scientific and general computation alike. There are two languages better known to physicists, Python and C/C++, which have an ocean of tools that could be utilized if PHITS were able to be run in them: Python has ML APIs such as Tensorflow and PyTorch, while NVIDIA's CUDA framework is written to provide GPU acceleration for C/C++. Not to menton the FitsGeo module, which handles PHITS geometry files. 

These can be accomplished iteratively: use the standard tools to create a C/C++ binding for the Fortran source, and then use the standard tools to create a Python binding for the C/C++ source. There does exist a oneshot tool for generating Python bindings for Fortran sources (the numpy project's F2PY), and there may be a performance difference between the two methods.

I'll use this file to document progress & organize my thoughts, as well as a "notebook" environment where I can mix executable Fortran and Python blocks.

Reminder: fortran block macro is =<ft=

* Via F2PY

F2PY is documented [[https://numpy.org/doc/stable/f2py/index.html][here]]. There are three (shown) ways of using it to create bindings useable in Python:

** Shell Construction

The quick-and-dirty way. Just run

#+begin_src shell

  python -m numpy.f2py -c <fortran source> -m <output module name>

#+end_src

Advantages:

- quick & easy
- Automation with sed, awk, and friends
- Architecture-independent?

Disadvantages:

- No determination of Python argument intent, so very error-prone and type-unsafe without changes to Fortran source.
- Unclear if this problem persists if intents are provided in the source.
- Probably won't work on Windows

** Signature Files

Provide module signatures in a separate file that is used to parse intents of arguments. The file is generated via

#+begin_src shell

  python -m numpy.f2py <fortran source> -m <output module name> -h <signature file name>

#+end_src
  
and has Fortran-like syntax ([[https://numpy.org/doc/stable/f2py/signature-file.html][documentation]]). There are some interesting extensions to the syntax, notably threadsafe (automatically removes & reinstates GIL).

#+begin_src fortran

  !    -*- f90 -*-

  python module fib2 ! in 
      interface  ! in :fib2
          subroutine fib(a,n) ! in :fib2:fib1.f
              real*8 dimension(n) :: a
              integer optional,check(len(a)>=n),depend(a) :: n=len(a)
          end subroutine fib
      end interface 
  end python module fib2

  ! This file was auto-generated with f2py (version:2.28.198-1366).
  ! See http://cens.ioc.ee/projects/f2py2e/
      
#+end_src

This file must be modified to reflect that "a" is an output argument and "n" is an input argument, as well as associated dependence of the arguments. For the example,

#+begin_src fortran

  !    -*- f90 -*-      

  python module fib2 
      interface
          subroutine fib(a,n)
              real*8 dimension(n),intent(out),depend(n) :: a
              integer intent(in) :: n
          end subroutine fib
      end interface
  end python module fib2

#+end_src

Advantages:

- Does not require source code (only knowledge of each signature)
- Removes bugginess of resulting Python code
- Allows customization of the Python syntax
- Signature file is a build script?

Disadvantages:

- Brevity
- Harder to integrate with UNIX utils
- Requires creating additional non-source files, complicating automation of the build process. 

** F2PY Directives

The generation of signature files can be bypassed by including intents in the Fortran source. This is done through directive comments:

#+begin_src fortran

  !     FILE: FIB3.F
        SUBROUTINE FIB(A,N)
  !
  !     CALCULATE FIRST N FIBONACCI NUMBERS
  !
        INTEGER N
        REAL*8 A(N)
  !f2py intent(in) n
  !f2py intent(out) a
  !f2py depend(n) a
        DO I=1,N
           IF (I.EQ.1) THEN
              A(I) = 0.0D0
           ELSEIF (I.EQ.2) THEN
              A(I) = 1.0D0
           ELSE 
              A(I) = A(I-1) + A(I-2)
           ENDIF
        ENDDO
        END
  !     END FILE FIB3.F

#+end_src

The generation of the Python modules is then the single command

#+begin_src shell

  python -m numpy.f2py -c -m <output module name> <fortran source>

#+end_src

Advantages:

- UNIX utillity integration as easy as the first method
- Doesn't depend on existence of helper files = easier to automate build process

Disadvantages:

- Requires editing of source files
  
** Using the Bindings

Once the wrapping is completed, objects of type =fortran= are exposed to the Python consumer. These have children corresponding to all functions and =COMMON= blocks defined in the Fortran source, identically to how Python modules behave normally. Interestingly, F2PY also supports calling Python code via Fortran's =external= keyword. Should modifications to the PHITS source prove possible, this could enable some more intensive modifications to it.  

* Via Cython

The [[https://www.fortran90.org/src/best-practices.html#interfacing-with-python][Fortran documentation]] reccomends first using the =iso_c_binding= module to generate an ISO C version of the Fortran program, and then using Cython or built-in ctypes to bind that into Python. A comparison of the speed with this and F2PY is in order, as perhaps the package does some further optimizations than this method or introduces unnecessary overhead.

Advantages:

- Generates a C/C++ binding, which is just as useful as the Python binding in its own right.
- Fortran compiler does enough compile-time checking that the C binding is guaranteed to be accurate.
- Python thinks it's working with C---no dependency beyond Cython, which is probably better known & maintained than F2PY.
  
Disadvantages:

- Requires editing the source code
- Since C has no dynamic arrays, all arrays must have declared length. (F2PY has no such restriction)
- Likely would require some Python library code to abstract away the Cython/ctypes and generate nice pythonic code.
- Single-threaded?

* Speed Comparison

We'll test the following function for finding the GCD:

#+begin_src fortran :tangle ./testprog.f90
   
        FUNCTION NGCD(NA, NB)
          IA = NA
          IB = NB
      1   IF (IB.NE.0) THEN
            ITEMP = IA
            IA = IB
            IB = MOD(ITEMP, IB)
            GOTO 1
          END IF
          NGCD = IA
          RETURN
          END
      
#+end_src


