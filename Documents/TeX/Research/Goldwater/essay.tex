\documentclass[12pt, arial, letterpaper]{article}

\usepackage{helvet}
\renewcommand{\familydefault}{\sfdefault}
\usepackage[margin=1in]{geometry}

\usepackage{cite}

\usepackage{fancyhdr}
\pagestyle{fancy}
\fancyhf{}

\lhead{Duncan Wilkie}
\rhead{Louisiana State University}



\begin{document}
\section*{A Hardware Definition Language for Quick Implementation of Messaging Protocols in FPGAs}
Field-programmable gate arrays (FPGAs) provide alternatives to microcontrollers for embedded development. They often provide faster speeds and lower power consumption than their counterparts \cite{mal}. However, this can come at the cost of increased development time: our lab decided against use of an FPGA in a recent embedded project, despite the project calling for high data throughput and low power draw, precisely because of a time crunch. Existing hardware definition languages (HDLs) used to create FPGA circuits \cite{vlog}\cite{vhdl} are very general-purpose, and programmers must spend a large amount of time concerned with implementation details that are largely secondary to their objectives. In a word, they are too low-level to enable fast development of solutions to simple problems by small teams. A potential solution to this problem is to borrow from UNIX philosophy: have many interoperable languages of narrow scope built on top of a common low-level foundation, each with syntax optimized for brief resolution of the problems to which they are tailored. I propose the following coarse specification for such a purpose-specific HDL designed for easy implementation of hardware communication protocols, inspired by precisely the problem we ought to have used an FPGA for.
\newline

The basic task of interpreting a hardware message is this:
``I see some streams of binary data on some pins.
I have a specification the data should conform to.
Perform actions based on the given binary data when interpreted according to the specification.''
\newline

Before streams of binary data are interpretable, it is usually necessary to shuffle around the order of incoming bits into intelligible units based on the physical link used. For example, in standard serial communication one must take each sequence of eight bits off a single pin as a byte, whereas in eight-bit parallel communication one must compose the eight bits from each of the data pins into a byte in a specified order. This is the purpose of the first section of the program: to perform these kinds of stream reshape operations on specified pins. The result is a stream of structured data that is fed to the next section of the program.
\newline

After the input is interpreted in the correct general format, it can be compared to a specification. Inspiration as to precisely how is drawn from Haskell's pattern matching system \cite{Marlow_haskell2010} and the BNF grammar specification  language family\cite{bnf}. The hope is that the intuitive, mathematical syntax will allow effortless translation from protocol specification documents to this part of a program. In this section, data from the input streams is taken until either it matches the specified pattern or it stops matching the specified pattern (depending on whether greedy or non-greedy behavior is desired). Once the final match is found, identifiers appearing in the pattern are bound to values in the stream, and execution proceeds to the next section.
\newline

The final step most closely resembles standard imperative programs. Based on the variables produced in the above step, a series of commands are issued to perform whatever actions need be done as a result, such as outputting the received data in a different format or calling a computation on it.
\newline

The following program is an example for a very simple message structure, showcasing how these elements might work.
\begin{verbatim}

input a1:
  chunked(a1, 8) // produce stream of bytes from pin a1

match:
  0x5f        // start of packet MSB
  0xf0 | 0xf1 // start of packet LSB options
  packetID // bind identifier packetID to the binary value here
  msgSize @length  // tell the compiler this value influences matching
  headerCHK

  payload* // A payload can be any number of bytes

  payloadCHK

do:
  if checksum(payload) != payloadCHK or checksum(0, 5) != headerCHK:
      return
  else:
      computation(payload)

\end{verbatim}


I intend to fully specify this language, including its module system, typing, primitives, standard library, and so on. Once that is completed, I'll plug the grammar into the ANTLRv4 parser generator \cite{antlr} to produce a program capable of lexing and parsing source files for the language. I'll then fill in the parser actions to produce the compiled SystemVerilog program. This may then be directly applied to FPGAs via the vendor-supplied compiler toolchains.
I know very little about SystemVerilog and FPGA computation in general, and hope to greatly expand my capacities in that area as well as compiler and programming language design.
\newline

The long-term stretch goal of working on this and similar projects is to form a whole class of interoperable domain-specific languages, as mentioned above. A significant amount of work has been put into the development of reconfigurable computing systems over the years\cite{moth} due to the wild parallelism possible with FPGAs, but activity appears concentrated in 2000-2010, with projects like ReconOS\cite{recon}, a reconfigurable computing operating system, seeing no commits in four years. I see no reason for the draw of FPGA compute to have diminished; it seems there's a wealth of opportunity to get computational physics on the bleeding edge of computing performance again.

\bibliography{ref}
\bibliographystyle{ieeetr}
\end{document}
%%% Local Variables:
%%% mode: latex
%%% TeX-master: t
%%% End:
